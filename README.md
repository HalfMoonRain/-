# 면접준비
## Q.1 프로그램이 무엇인가?
- 컴퓨터가 사람 일을 할 수 있도록 해주는 것

- 컴퓨터에 처리되는 작업의 순서를 논리적으로 명령어로 작성하는 것



## Q.2 JAVA의 장단점
장점

자바의 가장 큰 장점은 JVM을 이용한 플랫폼 독립적이라는 점입니다. 자바에서 코드를 컴파일하면 바이트코드(.class) 형태로 출력됩니다. 이 바이트코드는 JVM에 런타임에 완벽한 기계 코드로 변경되어 실행됩니다. 하나의 바이트코드를 가지고 서로 다른 기계마다 해당 JVM만 설치되어있으면 다시 컴파일할 필요 없이 나머지는 JVM에서 해당 기계에 맞도록 실행해줍니다. 그 밖에 C언어 계열에서 지원하는 포인터 연산을 과감하게 배제하여 안정성 있는 코드 작성에 집중할 수 있도록 했습니다. 또한 객체지향 프로그래밍을 완벽하게 지원합니다. 마지막으로 다양한 기본 클래스와 멀티쓰레딩, 네트워킹 API를 지원합니다.



요약

객체지향형 프로그래밍 언어, 플랫폼 독립적, 이식성이 좋다.(DI), 라이브러리 지향성, 보안성, 멀티 스레드, JVM사용으로 다양한 OS에서 사용 가능



단점

자바의 단점은 JVM을 사용하는데서 발생하는데에 있습니다. 자바 프로그램이 실행되기 위해서는 먼저 JVM이 실행되어야 하는데 JVM 실행 과정은 생각보다 많은 메모리를 소모하며 실행 속도 또한 빠르지 않습니다. 또한 바이트코드를 완전한 기계 코드로 변환하는 과정에서도 일반적인 컴파일 언어로 작성된 프로그램보다 속도가 많이 느립니다.



요약

느린속도, 불편한 예외처리, 실시간 응용 시스템에 부적합



## Q.3 Primitive Type과 Reference Type에 대해 설명하세요.
 기본 자료형(Primitive Type)은 byte, short, int, long, float, double, char, boolean이 존재합니다. 기본 자료형으로 생성한 변수에는 값 자체가 저장됩니다. 사용전에 반드시 선언되어야하며 OS에 따라 자료형의 길이가 변하지 않고 null 값을 갖을수 없는 특징이 있습니다.

 참조 자료형(Referenct Type)은 class, interface, array, enum이 존재합니다. 참조 자료형으로 생성한 변수에는 객체의 주소값이 저장됩니다. 생성자를 이용하여 새로운 객체의 주소를 가리키거나 null 값을 이용하여 해제할 수 있습니다.



요약

-primitive type은 변수에 값 자체를 저장하며, reference type은 메모리 상에 객체가 있는 위치를 저장한다.

-Primitive Type의 종류에는 Boolean, Byte, char, short, int, float, long, double 총 8가지 이며 

 Reference Type의 종류에는 클래스 타입, 인터페이스 타입, 배열 타입, 열거타입이 있다.



## Q.4 배열과 컬렉션의 차이점에 대해서 설명하세요

-배열은 단 하나의 자료형만 저장이 가능하고, 컬렉션은 복수의 자료형을 저장 할 수 있다.

-배열은 고정된 크기이고, 컬렉션은 가변된 크기이다.



## Q.5 Java 컬렉션의 대표 인터페이스는 무엇이 있는가?

List

-순서가 있는 데이터의 집합으로 데이터의 중복을 허용한다.

-구현클래스 : ArrayList, LinkedList, Stack, Vector

<p align = "center">
 <img src = "https://blog.kakaocdn.net/dn/bxSQdR/btqTyBzXfTx/Jg0RdLWPPDZhnPv2ywDZ3k/img.png" height = "40%" width = "60%">
 </p>
###### ArrayList는 index가 있고, LinkedList는 각 원소마다 앞, 뒤 원소의 위치값을 가지고 있다.
ArrayList

ArrayList는 기본적으로 배열을 사용한다. 하지만 일반 배열과 차이점이 존재한다.

일반 배열은 처음에 메모리를 할당할 때 크기를 지정해주어야 하지만,

ArrayList는 크기를 지정하지 않고 동적으로 값을 삽입하고 삭제할 수 있다.

 

조회

ArrayList는 각 데이터의  index를 가지고 있고 무작위 접근이 가능하기 때문에, 해당 index의 데이터를 한번에 가져올 수 있다.

 

데이터 삽입과 삭제

데이터의 삽입과 삭제시 ArrayList는 그만큼 위치를 맞춰주어야 한다.

위의 사진으로 예를들면 5개의 데이터가 있을 때 맨 앞의 2를 삭제했다면 나머지 뒤의 4개를 앞으로 한칸씩 이동해야 한다.

삽입과 삭제가 많다면 ArrayList는 비효율적이다.

 

LinkedList

LinkedList는 내부적으로 양방향의 연결 리스트로 구성되어 있어 참조하려는 원소에 따라 처음부터 정방향 또는 역순으로 순회 가능

(배열의 단점을 보완하기 위해 LinkedList가 고안되었다.)

 

조회

LinkedList는 순차적 접근이기 때문에 검색의 속도가 느리다.

 

데이터 삽입과 삭제

LinkedList는  데이터를 추가·삭제시 가리키고 있는 주소값만 변경해주면 되기 때문에 ArrayList에 비해 상당히 효율적이다.

위의 사진으로 예를들면 2번째 값을 삭제하면 1번째 노드가 3번째 노드를 가리키게 하기만 하면 된다.

 

결론

이처럼 조회시에는 ArrayList가 우위에 있지만,

삽입/삭제 시에는 LinkedList가 뛰어난 성능을 보여준다.

 

소량의 데이터를 가지고 사용할 때는 사실 큰 차이가 없지만,

정적인 데이터를 활용하면서 조회가 빈번하다면 ArrayList를 사용하는 것이 좋고,

동적으로 추가/삭제 요구사항이 빈번하다면 LinkedList를 사용하는 것이 좋다.

Set

-순서를 유지하지 않는 데이터의 집합으로 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.

-구현클래스 : HashSet, TreeSet



Map

-키와 값의 쌍으로 이루어진 데이터의 집합으로 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.

-구현클래스 - HashMap, TreeMap, HashTable, Properties


