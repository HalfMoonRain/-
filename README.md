# 면접준비
## Q.1 프로그램이 무엇인가?
- 컴퓨터가 사람 일을 할 수 있도록 해주는 것

- 컴퓨터에 처리되는 작업의 순서를 논리적으로 명령어로 작성하는 것



## Q.2 JAVA의 장단점
장점

자바의 가장 큰 장점은 JVM을 이용한 플랫폼 독립적이라는 점입니다. 자바에서 코드를 컴파일하면 바이트코드(.class) 형태로 출력됩니다. 이 바이트코드는 JVM에 런타임에 완벽한 기계 코드로 변경되어 실행됩니다. 하나의 바이트코드를 가지고 서로 다른 기계마다 해당 JVM만 설치되어있으면 다시 컴파일할 필요 없이 나머지는 JVM에서 해당 기계에 맞도록 실행해줍니다. 그 밖에 C언어 계열에서 지원하는 포인터 연산을 과감하게 배제하여 안정성 있는 코드 작성에 집중할 수 있도록 했습니다. 또한 객체지향 프로그래밍을 완벽하게 지원합니다. 마지막으로 다양한 기본 클래스와 멀티쓰레딩, 네트워킹 API를 지원합니다.



요약

객체지향형 프로그래밍 언어, 플랫폼 독립적, 이식성이 좋다.(DI), 라이브러리 지향성, 보안성, 멀티 스레드, JVM사용으로 다양한 OS에서 사용 가능



단점

자바의 단점은 JVM을 사용하는데서 발생하는데에 있습니다. 자바 프로그램이 실행되기 위해서는 먼저 JVM이 실행되어야 하는데 JVM 실행 과정은 생각보다 많은 메모리를 소모하며 실행 속도 또한 빠르지 않습니다. 또한 바이트코드를 완전한 기계 코드로 변환하는 과정에서도 일반적인 컴파일 언어로 작성된 프로그램보다 속도가 많이 느립니다.



요약

느린속도, 불편한 예외처리, 실시간 응용 시스템에 부적합



## Q.3 Primitive Type과 Reference Type에 대해 설명하세요.
 기본 자료형(Primitive Type)은 byte, short, int, long, float, double, char, boolean이 존재합니다. 기본 자료형으로 생성한 변수에는 값 자체가 저장됩니다. 사용전에 반드시 선언되어야하며 OS에 따라 자료형의 길이가 변하지 않고 null 값을 갖을수 없는 특징이 있습니다.

 참조 자료형(Referenct Type)은 class, interface, array, enum이 존재합니다. 참조 자료형으로 생성한 변수에는 객체의 주소값이 저장됩니다. 생성자를 이용하여 새로운 객체의 주소를 가리키거나 null 값을 이용하여 해제할 수 있습니다.



요약

-primitive type은 변수에 값 자체를 저장하며, reference type은 메모리 상에 객체가 있는 위치를 저장한다.

-Primitive Type의 종류에는 Boolean, Byte, char, short, int, float, long, double 총 8가지 이며 

 Reference Type의 종류에는 클래스 타입, 인터페이스 타입, 배열 타입, 열거타입이 있다.



## Q.4 배열과 컬렉션의 차이점에 대해서 설명하세요

-배열은 단 하나의 자료형만 저장이 가능하고, 컬렉션은 복수의 자료형을 저장 할 수 있다.

-배열은 고정된 크기이고, 컬렉션은 가변된 크기이다.



## Q.5 Java 컬렉션의 대표 인터페이스는 무엇이 있는가?

List

-순서가 있는 데이터의 집합으로 데이터의 중복을 허용한다.

-구현클래스 : ArrayList, LinkedList, Stack, Vector

<p align = "center">
 <img src = "https://blog.kakaocdn.net/dn/bxSQdR/btqTyBzXfTx/Jg0RdLWPPDZhnPv2ywDZ3k/img.png" height = "40%" width = "60%">
</p>

###### <p align = "center">ArrayList는 index가 있고, LinkedList는 각 원소마다 앞, 뒤 원소의 위치값을 가지고 있다.</p>

### ArrayList
ArrayList는 기본적으로 배열을 사용한다. 하지만 일반 배열과 차이점이 존재한다.

일반 배열은 처음에 메모리를 할당할 때 크기를 지정해주어야 하지만,

ArrayList는 크기를 지정하지 않고 동적으로 값을 삽입하고 삭제할 수 있다.

 

### 조회

ArrayList는 각 데이터의  index를 가지고 있고 무작위 접근이 가능하기 때문에, 해당 index의 데이터를 한번에 가져올 수 있다.

 

### 데이터 삽입과 삭제

데이터의 삽입과 삭제시 ArrayList는 그만큼 위치를 맞춰주어야 한다.

위의 사진으로 예를들면 5개의 데이터가 있을 때 맨 앞의 2를 삭제했다면 나머지 뒤의 4개를 앞으로 한칸씩 이동해야 한다.

삽입과 삭제가 많다면 ArrayList는 비효율적이다.

 

### LinkedList

LinkedList는 내부적으로 양방향의 연결 리스트로 구성되어 있어 참조하려는 원소에 따라 처음부터 정방향 또는 역순으로 순회 가능

(배열의 단점을 보완하기 위해 LinkedList가 고안되었다.)

 

### 조회

LinkedList는 순차적 접근이기 때문에 검색의 속도가 느리다.

 

### 데이터 삽입과 삭제

LinkedList는  데이터를 추가·삭제시 가리키고 있는 주소값만 변경해주면 되기 때문에 ArrayList에 비해 상당히 효율적이다.

위의 사진으로 예를들면 2번째 값을 삭제하면 1번째 노드가 3번째 노드를 가리키게 하기만 하면 된다.

 

### 결론

이처럼 조회시에는 ArrayList가 우위에 있지만,

삽입/삭제 시에는 LinkedList가 뛰어난 성능을 보여준다.

 

소량의 데이터를 가지고 사용할 때는 사실 큰 차이가 없지만,

정적인 데이터를 활용하면서 조회가 빈번하다면 ArrayList를 사용하는 것이 좋고,

동적으로 추가/삭제 요구사항이 빈번하다면 LinkedList를 사용하는 것이 좋다.

### Set

-순서를 유지하지 않는 데이터의 집합으로 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.

-구현클래스 : HashSet, TreeSet



### Map

-키와 값의 쌍으로 이루어진 데이터의 집합으로 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.

-구현클래스 - HashMap, TreeMap, HashTable, Properties

## Q.6 컬렉션에서 제너릭이 추가된 이유를 설명하세요.
컬렉션은 복수개의 테이터 타입  요소값이 저장되다 보니 원하는 자료형 타입 요소값을 추출하기 어렵다.

그러므로 지정한 자료형 타입 한가지만 저장하기 위해 있는 기능이 제너릭이다.

 

## Q.7 객체지향형이란?
객체 지향 프로그래밍은 코드를 작성하는 방법 중 하나 이며 코드를 정리하는 방법이다. 대표적으로 C#과 JAVA에서 사용이 된다.

OOP는 코드 재사용성과 생산성의 향상 효과 를 볼 수 있고, 유지보수의 편의성 덕택에 협업이 중요하고 규모가 큰 대형 프로젝트에 사용되는 프로그래밍 이론이다.

 

### OOP의 장점

코드 재사용성 증가상속을 통해 프로그래밍시 코드의 재사용을 높일 수 있다.
생산성 향상. 잘 설계된 클래스를 만들어서 독립적인 객체를 사용함으로써 개발의 생산성을 향상시킬 수 있다.
자연적인 모델링. 우리 일상생활의 모습의 구조가 객체에 자연스럽게 녹아들어 있기 때문에 생각하고 있는 것을 그대로 자연스럽게 구현할 수 있다.
유지보수의 우수성. 프로그램 수정시 추가, 수정을 하더라도 캡슐화를 통해 주변 영향이 적기때문에 유지보수가 쉬워서 매우 경제적이라할 수 있다.
OOP의 단점

개발속도가 느린점. 객체가 처리하려는 것에 대한 정확한 이해가 필요하기에 설계단계부터 많은 시간이 소모 된다.
실행속도가 느린점. 객체지향언어는 대체적으로 실행속도가 느리다.
코딩 난이도 상승. 다중 상속이 지원되는 C++ 같은 경우에 너무 복잡해져 코딩의 난이도가 상승할 수 있다.
OOP의 특징

객체 지향 프로그래밍의 가장 큰 특징은 클래스를 이용해 연관 있는 처리 부분(함수)과 데이터 부분(변수)을 하나의 객체(인스턴스)로 묶어 생성해 사용한다는 점이다.

객체 지향 프로그래밍은 캡슐화, 추상화, 상속성, 다형성 네 가지 특성을 지닌다.

 

### 캡슐화 (Encapsulation)

캡슐화란 데이터와 코드의 형태를 외부로부터 알 수 없게하고, 데이터의 구조와 역할, 기능을 하나의 캡슐형태로 만드는 방법이다.

캡슐화의 중요한 목적은 변수를 private로 선언하여 데이터를 보호하고, 보호된 변수는 getter나 setter등의 메서드를 통해서만 간접적으로 접근을 허용하는 것 이다.

캡슐화를 하면 불필요한 정보를 감출 수 있기 때문에, 정보은닉을 할 수 있다는 특징이 있다. 캡슐화와 정보은닉은 동일한 개념은 아니다.

### 추상화 (Abstraction)

추상화는 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 말한다.

다시 말해 실제로 존재하는 객체들을 프로그램으로 만들기 위해 공통 특성을 파악해 필요없는 특성을 제거하는 과정을 가르킨다.

객체들은 실제 그 모습이지만, 클래스는 객체들이 어떤 특징들이 있어야 한다고 정의하는 추상화된 개념이다.

정리하면 추상화는 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법이라 할 수 있다.

### 상속(Inheritance)

상속이란 기존 상위클래스에 기능을 가져와 재사용할 수 있으면서도 동시에 새로운 하위 클래스에 새로운 기능도 추가할 수 있는 것이다.

즉, 부모가 자식에게 유전자를 물려주듯이 부모의 특징을 자식에게 모두 물려준다.

OOP에서 이를 부모 클래스, 자식 클래스라고 표현한다.

상속이 필요한 이유는 코드의 중복을 없애기 위해서다.

코드의 중복이 많아지면 개발 단계와 유지 보수에서 많은 비용이 들게 된다.

상속관계를 맺으면 자식 객체를 생성할 때 부모 클래스의 속성들을 자동으로 물려받기 때문에 자식 클래스에서 또 정의할 필요가 없다.

### 다형성(Polymorphism)

다형성이란 상속과 연관있는 개념으로 한 객체가 상속을 통해 기능을 확장하거나 변경하여 다른 여러형태(객체)로 재구성 되는 것을 말한다.

쉽게 말하면 한 부모의 밑에서 태어난 자식들이 조금씩 다르다는 것이다.

오버로드(Overload) 또는 오버라이드(Override)가 다형성의 대표적인 예라 할 수있고, **이것을 구현하는 걸 오버로딩(Overloading)과 오버라이딩(Overriding)**이라고 한다.

간단하게 설명하자면,

**오버라이딩**은 하위 클래스(자식)가 상위 클래스(부모)에서 만들어진 메서드를 자신의 입맛대로 다시 재창조해서 사용하는 것을 말한다.

**오버로딩**은 하나의 클래스 안에서 같은 이름의 메서드를 사용하지만 각 메서드마다 다른 용도로 사용되며 그 결과물도 다르게 구현하는 것을 말한다.

오버로딩이 가능하려면 메서드끼리 이름은 같지만 매개변수의 개수나 데이터 타입이 달라야 한다.

다형성을 사용하면 같은 이름의 속성을 유지함으로서, 속성을 사용하기 위한 인터페이스를 유지하고, 메서드 이름을 낭비하지 않는다.

API가 많아질수록 복잡성은 증가하기 때문에 다형성은 유용하며 코드 재사용성을 늘려주어 유지보수가 용이하도록 도와주는 개념이다.

결국 OOP는 위 네 가지 특성들을 통해서 어떤 대상을 추상화(Abstraction)하여 공통점을 찾고, 그것을 캡슐화(Encapsulation)해 한 군데에 모아 객체를 만들고, 새로운 객체가 상속(Inheritance)받아 재사용이 가능하게 만들어 준다.

상속받은 객체는 다형성(Polymorphism)을 통해 기능을 수정 또는 추가하여 재사용할 수 있다.

 

## Q.8 쓰레드에 대해서 설명하세요.
스레드(thread)는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다.  멀티 쓰레드는 하나의 프로세스에서 여러개의 작업을 하게 해주는 기능이다. 멀티쓰레드는 두가지 이상의 작업을 동시에 실행하여 자원을 효율적으로 이용할 수 있게 해주는 장점이 있지만 dead lock 및 동기화에 대한 철저한 검증이 필요하다.

 

## Q.9 자바에서 멀티쓰레드를 구현하는 방법은?
멀티쓰레드를 구현하는 방법으로는 

- Thread 클래스를 상속하는 방법 --> 단일 상속만 된다는 단점이 있다. 

- Runnable 인터페이스를 상속하는 방법 --> 다중 상속이 된다는 장점이 있다.

## Q.10 접근제어자에 대해서 설명하시오
접근제어자는 객체지향 프로그래밍에서 클래스의 멤버 변수 또는 메소드에 설정하는 키워드로 접근 영역을 제한하는데 사용합니다. public, default, protected, private이 존재합니다.

- Default : 기본적인 값으로 따로 설정하지 않는 경우 입니다. 같은 패키지 내에서만 접근이 가능합니다.

- Public : 접근 제한이 없습니다.

- Protected : 같은 패키지 내 혹은 다른 패키지의 자식 클래스에서 접근이 가능함을 의미합니다.

- Private : 같은 클래스 내에서만 접근이 가능합니다. 

## Q.11 Wrapper 클래스에 대해서 설명하시오

Primitive 타입(기본 자료형) 으로 표현할 수 있는 간단한 데이터를 객체로 만들어야 할 경우가 있는데 그러한 기능을 지원하는 클래스를 뜻하며 각 기본형 타입에 대응하는 Wrapper 클래스는 다음과 같다.

<p align = "center">

|<center>기본 자료형</center>|<center>Wrapper 클래스</center>|
|:---:|:---:|
|<center>byte </center>|<center>Byte</center>|
|<center>short </center>|<center>Short</center>|
|<center>int</center>|<center>Integer</center>|
|<center>long</center>|<center>Long</center>|
|<center>char</center>|<center>Character</center>|
|<center>float</center>|<center>Float</center>|
|<center>double</center>|<center>Double</center>|
|<center>boolean</center>|<center>Boolean</center>|

</p>

## Q.12 변수와 상수의 차이에 대해서 설명하세요
변수

프로그램이 실행되면 메모리를 사용하여 정보를 기억시킨다.

메모리에 변수를 할당하고 필요할때마다 가져와서 사용

컴퓨터는 모든 신호를 숫자로 인지(문자라도 모두 0과1로 나타냄)

-> 변수 = 변하는 수(덮어쓸 수 있다.)

<p align = "center">

|분류|설명|시작|소멸|
|:---:|:---:|:---:|:---:|
|지역변수(Local Variable)|중괄호 {} 내에 선언 된 변수|중괄호 시작|중괄호 끝|
|매개변수(Parameter)|메소드에 넘겨주는 변수|메소드가 호출 될 때|메소드가 끝날 때|
|인스턴스변수(Instance Variable)|메소드 밖, 클래스 안에 선언된 변수|객체가 생성될 때 |그 객체를 참조하는 다른 객체가 없을 때|
|클래스변수(Class Variable)|인스턴스 변수 중 타입 선언 앞에 static이라는 예약어가 있는 변수|클래스가 처음 호출될 때|자바 프로그램이 끝날 때|
 
</p>

### 지역변수

선언 위치 : 클래스 영역 이외의 영역( 메소드, 생성자, 초기화 블럭 내부)
생성시기 : 변수 선언문이 수행 되었을 때

특징

- 특정한 구역(메소드, 생성자, 초기화 블록(( ), { })에 생성되어 그 지역에서만 사용할 수 있는 변수를 의미한다.
- 매개변수(parameter) 또한 메소드 내에 정의되는 지역변수이다.
- 지역 변수는 메모리상의 스택(stack) 영역에 저장된다.
- 지역변수는 변수가 선언된 블록 내에서만 유효하고, 블록이 종료되면 메모리에서 사라져 사용할 수 없게된다. (for문 while문도 동일)
- 지역변수들은 해당 블록을 벗어나면 소멸하게 되기때문에, 메소드에 선언된 변수가 있다면 그 지역변수는 메소드가 호출될 때마다 매번 새롭게 할당된다.

### 전역변수

- 클래스 영역(메소드 밖)에 선언된 변수를 의미한다.
- 프로그램이 실행되면 메모리 공간에 데이터를 저장한다.
- 전역 변수는 프로그램의 어디에나 접근할 수 있으며, 프로그램이 종료되어야만 메모리 영역에서 사라진다.
- 클래스변수: 다른 클래스에서도 호출이 가능
- 객체변수: 같은 클래스내에서 호출가능

### 인스턴스 변수 (객체 변수)

선언위치 : 클래스 영역
생성 시기 : 인스턴스(https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html)가 생성 되었을때

특징

- 같은 클래스내에서 호출 가능하다.
- 인스턴스 변수는 클래스영역 내에 선언되며 클래스의 인스턴스(객체)를 생성할 때 만들어진다.
- 인스턴스 변수의 값을 읽어오거나 저장하기 위해서는 먼저 인스턴스(객체)를 생성해야한다. 즉, 객체화를 시켜서 호출해야지만 사용이 가능하다
- 각 인스턴스(객체)마다 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.
- 고유한 상태를 유지해야하는 경우, 인스턴스 변수로 선언한다.

### 클래스 변수(Static 변수)

선언 위치 : 클래스 영역
선언 방법 : 인스턴스 변수 앞에 static
생성 시기 : 클래스가 메모리에 올라갈 때

특징
- 다른 클래스에서도 호출이 가능하다.
- 클래스 변수는 모든 인스턴스(객체)가 공통된 저장공간(변수)을 공유하게 된다. 그래서 클래스 변수를 공유 변수(shared variable)라고도 부르기도 한다.
- 변수 앞에 static 키워드를 붙여 선언하고, 객체화를 시키지 않고도 사용이 가능하다.
- 인스턴스(객체)를 생성하지 않고 언제라도 바로 사용할 수 있다는 특징이 있으며 '클래스이름.클래스변수' 와 같은 형식으로 사용할 수 있다.
- 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스 변수로 선언해야 한다.
- 클래스가 메모리에 로딩(Loading) 될때, 생성되어 프로그램이 종료때 까지 유지되며 public을 앞에 붙이면 같은 프로그램내에서 어디서나 접근할수 잇는 전역변수(global variable)의 성격을 갖는다.

### 상수

변할 수 없는 수

변수앞에 final을 붙여주면 상수로 변함.

-> 값이 변하면 큰일나는 경우에 사용



## Q.13추상 클래스(abstract class)와 인터페이스(interface)에 대해 설명하시오.
﻿ 추상 클래스는 abstract 키워드를 이용하여 미완성 메소드 즉, 형태만 정의해 놓고 몸체는 없는 상태를 포함하고 있는 클래스를 의미합니다. 추상 클래스는 상속에 큰 의미를 두고 있습니다. 클래스이기 때문에 extends 키워드를 이용하여 상속을 진행하며 이런 추상 클래스를 상속받은 자식 클래스에서는 반드시 미완성 메소드를 재정의해야합니다.



 인터페이스는 추상 클래스보다 추상화 정도가 높은 상태를 정의할 때 사용합니다. 인터페이스는 기능의 재정의에 큰 의미를 두고 있습니다. 멤버 변수와 일반 메소드를 가질 수 없으며 오직 상수와 추상 메소드만을 선언할 수 있습니다. implements 키워드를 이용하여 상속을 진행하며 자식 클래스에서 반드시 메소드를 재정의해야합니다. 그 밖에 인터페이스는 클래스에서 지원하지 않는 다중상속이 가능합니다.

## Q.14 자바의 메모리 구조에 대하여 설명하시오.
JVM

JVM 메모리 구조를 설명하기 전에 JVM이 무엇인지 알아야 합니다. JVM은 Java Virtual Machine의 약자로, 자바 가상 머신이라고 부릅니다. 그리고 자바와 운영체제 사이에서 중개자 역할을 수행하며, 자바가 운영체제에 구애 받지 않고 프로그램을 실행할 수 있도록 도와줍니다. 또한, 가비지 컬렉터를 사용한 메모리 관리도 자동으로 수행하며, 다른 하드웨어와 다르게 레지스터 기반이 아닌 스택 기반으로 동작합니다.

 

아래는 자바 프로그램의 실행 단계입니다.
<p align = "center">
 <img src = "https://blog.kakaocdn.net/dn/bKvBUn/btrD5RXRY5p/a6lmfS3P4n5LDhp17kezMK/img.png" height = "40%" width = "60%">
</p>

1. Source Code (.java) 파일을 Java Compiler를 통해서 Byte Code(.Class)파일로 변환한다. (컴퓨터가 이해할 수 있는 코드로 변환)
2. Byte Code로 변환된 파일을 JVM의 Class Loader 로 보낸다.
3. Class Loader는 말 그대로 Class 파일을 불러와서 메모리에 저장하는 역할을 한다.
4. Execution Engine 은 Class Loader에 저장된 Byte Code를 명령어 단위로 분류하여 하나씩 실행하게 하는 엔진이다.
5. Garbage Collector 는 사용하지 않거나 필요없는 객체들을 메모리에서 소멸시키는 역할을 한다.
6. Runtime Data Area (Memory Area) 는 JVM이 프로그램을 수행하기위해 운영체제로부터 할당받은 메모리 공간이다.
   이때 Runtime Data Area는 다음과 같은 구조를 갖는다.
 
<p align = "center">
 <img src = "https://blog.kakaocdn.net/dn/bnT9xW/btrDWKMqaKa/ms8uVlIS1MoyHSUP1Kj1ak/img.png" height = "40%" width = "60%">
</p>

1) Method Area

- JVM이 실행되면서 생기는 공간이다.
- Class 정보, 전역변수 정보, Static 변수 정보가 저장되는 공간이다.
- Runtime Constant Pool 에는 말 그대로 '상수' 정보가 저장되는 공간이다.
- 모든 스레드에서 정보가 공유된다.

2) Heap

- new 연산자로 생성된 객체, Array와 같은 동적으로 생성된 데이터가 저장되는 공간
- Heap에 저장된 데이터는 Garbage Collector 가 처리하지 않는한 소멸되지 않는다.
- Reference Type 의 데이터가 저장되는 공간
- 모든 스레드에서 정보가 공유된다.

3) Stack

- 지역변수, 메소드의 매개변수와 같이 잠시 사용되고 필요가 없어지는 데이터가 저장되는 공간
- Last In First Out, 나중에 들어온 데이터가 먼저 나간다
- 만약, 지역변수 이지만 Reference Type일 경우에는 Heap 에 저장된 데이터의 주소값을 Stack 에 저장해서 사용하게 된다.
- 스레드마다 하나씩 존재한다.

4) PC Register

- 스레드가 생성되면서 생기는 공간
- 스레드가 어느 명령어를 처리하고 있는지 그 주소를 등록한다.
- JVM이 실행하고 있는 현재 위치를 저장하는 역할

5) Native Method Stack

- Java 가 아닌 다른 언어 (C, C++) 로 구성된 메소드를 실행이 필요할 때 사용되는 공간
